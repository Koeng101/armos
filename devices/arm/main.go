/* Package main is a Golang REST API for interacting with robotic arms.

The armos server sends this API requests for the robot to move or to go to an
`a,b,c,x,y,z` position. This only supports the AR3 robotic arm right now, but
we hope to add more in the future.
*/
package main

import (
	_ "modernc.org/sqlite"
	"github.com/jmoiron/sqlx"
	"os"
	"encoding/json"
	"fmt"
	"github.com/koeng101/armos/devices/arm/ar3"
	_ "github.com/koeng101/armos/devices/arm/docs" // API docs generated by swaggo/swag
	"github.com/swaggo/swag"
	"io/ioutil"
	"log"
	"net/http"
)

// App is a struct containing all information about the currently deployed
// application, such as the router and database.
type App struct {
	Router *http.ServeMux
	DB     *sqlx.DB
	Arm    ar3.AR3
}

// initalizeApp initializes an App for all endpoints to use.
func initializeApp(db *sqlx.DB, ar3 ar3.AR3) App {
	var app App
	app.Router = http.NewServeMux()
	app.DB = db
	app.Arm = ar3

	// Set arm directions from database
	var j JointDirections
	_ = app.DB.Get(&j, "SELECT j1, j2, j3, j4, j5, j6, tr FROM directions WHERE id=1")
	app.Arm.SetDirections(j.J1, j.J2, j.J3, j.J4, j.J5, j.J6, j.Tr)

	// Basic routes
	app.Router.HandleFunc("/api/ping", app.Ping)
	app.Router.HandleFunc("/swagger.json", app.SwaggerJSON)
	app.Router.HandleFunc("/docs", app.SwaggerDocs)

	// Setup routes
	app.Router.HandleFunc("/api/set_directions", app.SetDirections)
	app.Router.HandleFunc("/api/directions", app.Directions)

	// Low level routes
	app.Router.HandleFunc("/api/calibrate", app.Calibrate)
	app.Router.HandleFunc("/api/movesteppers", app.MoveSteppers)

	return app
}

// @title ArmOS arm API
// @version 0.1
// @description The arm API for ArmOS to interact with a variety of different robotic arms, starting with the AR3. It uses the basic interface of `x,y,z,a,b,c` for control.
// @BasePath /api/
func main() {
	var dbUrl string
	dbUrl = os.Getenv("DATABASE_URL")
	if dbUrl == "" {
		dbUrl = ":memory:"
	}
	db, err := sqlx.Open("sqlite", dbUrl)
	if err != nil {
		log.Fatalf("Failed to connect to database with error: %s", err)
	}
	defer db.Close()
	_, err = db.Exec(Schema)
	if err != nil {
		log.Fatalf("Failed on CreateDatabase with error: %s", err)
	}
	app := initializeApp(db, ar3.ConnectMock())

	// Serve application
	s := &http.Server{
		Addr:    ":8080",
		Handler: app.Router,
	}
	log.Fatal(s.ListenAndServe())
}

/******************************************************************************

                                armos arm dev

1. Ping does a basic ping of the service
2. SwaggerJSON provides full swagger docs for the API
3. SwaggerDocs provides a convenient human-readable API

******************************************************************************/

// Ping is a simple route for verifying that the service is online.
// @Summary A pingable endpoint
// @Tags dev
// @Produce plain
// @Success 200 {string} map[string]string
// @Router /ping [get]
func (app *App) Ping(w http.ResponseWriter, r *http.Request) {
	encoder := json.NewEncoder(w)
	_ = encoder.Encode(map[string]string{"message": "Online"})
}

// SwaggerJSON provides the swagger docs for this api in JSON format.
func (app *App) SwaggerJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Access-Control-Allow-Origin", "*")
	doc, _ := swag.ReadDoc()
	_, _ = w.Write([]byte(doc))
}

// SwaggerDocs provides a human-friendly swagger ui interface.
func (app *App) SwaggerDocs(w http.ResponseWriter, r *http.Request) {
	// https://stackoverflow.com/questions/55733609/display-swagger-ui-on-flask-without-any-hookups
	doc, _ := swag.ReadDoc()
	swaggerDoc := fmt.Sprintf(`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="//unpkg.com/swagger-ui-dist@3/swagger-ui-standalone-preset.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/3.22.1/swagger-ui-standalone-preset.js"></script> -->
    <script src="//unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/3.22.1/swagger-ui-bundle.js"></script> -->
    <link rel="stylesheet" href="//unpkg.com/swagger-ui-dist@3/swagger-ui.css" />
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/3.22.1/swagger-ui.css" /> -->
    <title>Swagger</title>
</head>
<body>
    <div id="swagger-ui"></div>
    <script>
        window.onload = function() {
          SwaggerUIBundle({
	    spec: %s,
            dom_id: '#swagger-ui',
            presets: [
              SwaggerUIBundle.presets.apis,
              SwaggerUIStandalonePreset
            ],
            layout: "StandaloneLayout"
          })
        }
    </script>
</body>
</html>`, doc)
	_, _ = w.Write([]byte(swaggerDoc))
}

/******************************************************************************

                                armos arm setup

1. /direction sets up the robotic directions and saves it to a local database.

******************************************************************************/

// Schema represents the SQLite schema of the local database for directions and
// command tracking
var Schema string = `
CREATE TABLE IF NOT EXISTS directions(
	id INTEGER PRIMARY KEY,
	j1 INTEGER NOT NULL DEFAULT 0,
	j2 INTEGER NOT NULL DEFAULT 0,
	j3 INTEGER NOT NULL DEFAULT 0,
	j4 INTEGER NOT NULL DEFAULT 0,
	j5 INTEGER NOT NULL DEFAULT 0,
	j6 INTEGER NOT NULL DEFAULT 0,
	tr INTEGER NOT NULL DEFAULT 0
);

CREATE TABLE IF NOT EXISTS history(
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	command TEXT NOT NULL,
	commandjson TEXT NOT NULL
);

INSERT OR IGNORE INTO directions(id) VALUES (1);
`

// JointDirections saves the directions of stepper motors in the database.
// Directions can be set with 0 or 1.
type JointDirections struct {
	J1    bool `json:"j1" db:"j1"`
	J2    bool `json:"j2" db:"j2"`
	J3    bool `json:"j3" db:"j3"`
	J4    bool `json:"j4" db:"j4"`
	J5    bool `json:"j5" db:"j5"`
	J6    bool `json:"j6" db:"j6"`
	Tr    bool `json:"tr" db:"tr"`
}

// SetDirections sets the correct direction of the arm's motors.
// @Summary Sets direction of arm joints
// @Tags setup
// @Description Sets up the robots joints. This only has to be done once during the setup of the robot.
// @Accept json
// @Produce plain
// @Param directions body JointDirections true "direction of joints"
// @Success 200 {string} string
// @Failure 400 {string} string
// @Router /set_directions [post]
func (app *App) SetDirections(w http.ResponseWriter, r *http.Request) {
	// Read body
        reqBody, err := ioutil.ReadAll(r.Body)
        if err != nil {
                w.WriteHeader(400)
                _ = json.NewEncoder(w).Encode(err.Error())
                return
        }

        // Unmarshal
        var j JointDirections
        err = json.Unmarshal(reqBody, &j)
        if err != nil {
                w.WriteHeader(400)
                _ = json.NewEncoder(w).Encode(err.Error())
                return
        }

	// Update directions
	_, err = app.DB.Exec("UPDATE directions SET j1=?, j2=?, j3=?, j4=?, j5=?, j6=?, tr=? WHERE id=1", j.J1, j.J2, j.J3, j.J4, j.J5, j.J6, j.Tr)
	if err != nil {
		w.WriteHeader(400)
                _ = json.NewEncoder(w).Encode(err.Error())
                return
        }

	// Set the direction of the arm itself.
	app.Arm.SetDirections(j.J1, j.J2, j.J3, j.J4, j.J5, j.J6, j.Tr)

	_ = json.NewEncoder(w).Encode("success")
}

// Directions returns current directions of the arm's motors.
// @Summary Returns direction of arm joints
// @Tags setup
// @Description Returns current direction of arm's motors.
// @Produce json
// @Success 200 {object} JointDirections
// @Failure 400 {object} string
// @Router /directions [get]
func (app *App) Directions(w http.ResponseWriter, r *http.Request) {
	var j JointDirections
	j1, j2, j3, j4, j5, j6, tr := app.Arm.GetDirections()
	j.J1 = j1
	j.J2 = j2
	j.J3 = j3
	j.J4 = j4
	j.J5 = j5
	j.J6 = j6
	j.Tr = tr

	_ = json.NewEncoder(w).Encode(j)
}

/******************************************************************************

				armos arm low-level

1. /calibrate calibrates the robotic arm to its limit switches.
2. /movesteppers moves the robotic arm a certain number of steps.

******************************************************************************/

// CalibrateInput is the input to a calibration. This is usually just the set
// of joints to calibrate to their respective limit switches.
type CalibrateInput struct {
	Speed int  `json:"speed"`
	J1    bool `json:"j1"`
	J2    bool `json:"j2"`
	J3    bool `json:"j3"`
	J4    bool `json:"j4"`
	J5    bool `json:"j5"`
	J6    bool `json:"j6"`
	Tr    bool `json:"tr"`
}

// Calibrate calibrates the robot to its limit switches.
// @Summary Calibrate the arm
// @Tags low_level
// @Description Calibrates the robot. Should be done occasionally to affirm the robot is where we think it should be.
// @Accept json
// @Produce plain
// @Param joints body CalibrateInput true "joints to calibrate"
// @Success 200 {string} string
// @Failure 400 {string} string
// @Router /calibrate [post]
func (app *App) Calibrate(w http.ResponseWriter, r *http.Request) {
	// Read body
	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(400)
		_ = json.NewEncoder(w).Encode(err.Error())
		return
	}

	// Unmarshal
	var c CalibrateInput
	err = json.Unmarshal(reqBody, &c)
	if err != nil {
		w.WriteHeader(400)
		_ = json.NewEncoder(w).Encode(err.Error())
		return
	}

	// Calibrate those joints
	err = app.Arm.Calibrate(c.Speed, c.J1, c.J2, c.J3, c.J4, c.J5, c.J6, c.Tr)
	if err != nil {
		w.WriteHeader(400)
		_ = json.NewEncoder(w).Encode(err.Error())
		return
	}

	_ = json.NewEncoder(w).Encode("success")
}

// MoveStepperInput is the input to a MoveStepper command.
type MoveStepperInput struct {
	Speed  int `json:"speed"`
	Accdur int `json:"accdur"`
	Accspd int `json:"accspd"`
	Dccdur int `json:"dccdur"`
	Dccspd int `json:"dccspd"`
	J1     int `json:"j1"`
	J2     int `json:"j2"`
	J3     int `json:"j3"`
	J4     int `json:"j4"`
	J5     int `json:"j5"`
	J6     int `json:"j6"`
	Tr     int `json:"tr"`
}

// MoveSteppers moves the robots stepper motors a certain number of steps.
// @Summary Move the arm's stepper motors
// @Tags low_level
// @Description Moves the robot's stepper motors.
// @Accept json
// @Produce plain
// @Param move body MoveStepperInput true "steppers coordinates"
// @Success 200 {string} string
// @Failure 400 {string} string
// @Router /move [post]
func (app *App) MoveSteppers(w http.ResponseWriter, r *http.Request) {
	// Read body
	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(400)
		_ = json.NewEncoder(w).Encode(err.Error())
		return
	}

	// Unmarshal
	var m MoveStepperInput
	err = json.Unmarshal(reqBody, &m)
	if err != nil {
		w.WriteHeader(400)
		_ = json.NewEncoder(w).Encode(err.Error())
		return
	}

	// MoveSteppers
	err = app.Arm.MoveSteppers(m.Speed, m.Accdur, m.Accspd, m.Dccdur, m.Dccspd, m.J1, m.J2, m.J3, m.J4, m.J5, m.J6, m.Tr)
	if err != nil {
		w.WriteHeader(400)
		_ = json.NewEncoder(w).Encode(err.Error())
		return
	}

	_ = json.NewEncoder(w).Encode("success")
}
